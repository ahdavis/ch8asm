/*
 * preprocessor.rs
 * Defines a struct that preprocesses Chip-8 assembly code
 * Created on 12/11/2019
 * Created by Andrew Davis
 *
 * Copyright (C) 2019  Andrew Davis
 *
 * This program is free software: you can redistribute it and/or modify   
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//usage statements
use super::super::lex::*;
use super::super::util::Variant;
use super::AddrTable;
use std::process::exit;

/// Preprocesses Chip-8 assembly code
pub struct Preprocessor {
    /// Lexes the source code and produces tokens
    lexer: PrepLexer,

    /// The current token being processed
    cur_token: Token
}

//implementation
impl Preprocessor {
    /// Constructs a new `Preprocessor` instance
    ///
    /// # Argument
    ///
    /// * `new_code` - The code to preprocess 
    /// 
    /// # Returns
    ///
    /// A new `Preprocessor` instance with the given lexer
    pub fn new(new_code: &str) -> Self {
        //and return the instance
        return Preprocessor {
            lexer: PrepLexer::new(new_code),
            cur_token: Token::new(TokenType::EndOfInput,  
                                  Variant::Byte(0xFF))
        };
    }

    /// Preprocesses the source code given to the lexer 
    ///
    /// # Panics
    ///
    /// This method will panic if a non-text token
    /// is generated by the lexer. 
    ///
    /// # Returns
    ///
    /// An `AddrTable` instance containing the preprocessed text
    pub fn process(&mut self) -> AddrTable {
        //create the table
        let mut ret = AddrTable::new();

        //loop and preprocess the text
        loop {
            //get the current token
            match self.lexer.get_next_token() {
                Ok(t) => self.cur_token = t,
                Err(err) =>  {
                    println!("{}", err);
                    exit(1)
                }
            };

            //add the token to the table if it's not an EOI or 
            //label reference token
            if (self.cur_token.get_type() != TokenType::EndOfInput)
                && (self.cur_token.get_type() != TokenType::Label) {
                let tr = self.cur_token.get_value().as_text();
                match tr {
                    Ok(t) => ret.add_entry(&t, self.lexer.get_address()),
                    Err(err) => {
                        println!("{}", err);
                        exit(1)
                    }
                };
            }

            //and determine whether to end the loop
            if self.cur_token.get_type() == TokenType::EndOfInput {
                break;
            }
        }

        //and return the table
        return ret;
    }
}

//unit tests
#[cfg(test)]
mod tests {
    //imports
    use super::*;
    use super::super::super::util::constants;

    //define the code string
    const CODE: &str = "_start: 
                mov V1, V2 
                _loop:
                sch V1
                jmp _loop
                jmp _end";

    //this test checks preprocessing code
    #[test]
    fn test_preprocess() {
        let mut prep = Preprocessor::new(CODE);
        let tab = prep.process();
        assert!(tab.has_entry("_start"));
        assert!(tab.has_entry("_loop"));
        assert_eq!(tab.has_entry("_end"), false);
        let start_addr = tab.get_entry("_start").unwrap();
        assert_eq!(start_addr, constants::MEM_START);
        let loop_addr = tab.get_entry("_loop").unwrap();
        assert_eq!(loop_addr, constants::MEM_START + 2);
    }
}

//end of file
